"""
Synthetic Data Pipeline - Orchestrates the complete pipeline from Synthea to embeddings
"""

import asyncio
import json
import logging
import os
import subprocess
from pathlib import Path
from typing import List, Dict, Any
import uuid

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text

from app.core.config import get_settings
from app.services.fhir_processor import FHIRProcessor
from app.services.phi_deidentifier import PHIDeidentifier
from app.services.embedding_service import EmbeddingService

logger = logging.getLogger(__name__)
settings = get_settings()


class SyntheticDataPipeline:
    """Complete synthetic data pipeline orchestrator"""
    
    def __init__(self, db_session: AsyncSession):
        self.db = db_session
        self.fhir_processor = FHIRProcessor()
        self.deidentifier = PHIDeidentifier()
        self.embedding_service = EmbeddingService()
        
        # Ensure directories exist
        self.data_dir = Path("./data")
        self.fhir_dir = self.data_dir / "fhir"
        self.processed_dir = self.data_dir / "processed"
        
        for directory in [self.data_dir, self.fhir_dir, self.processed_dir]:
            directory.mkdir(parents=True, exist_ok=True)
    
    async def run_full_pipeline(
        self, 
        num_patients: int = 500, 
        specialties: List[str] = ["oncology", "rheumatology"]
    ) -> Dict[str, Any]:
        """
        Run the complete pipeline:
        1. Generate synthetic patients with Synthea
        2. Process FHIR bundles and extract clinical notes
        3. De-identify PHI using Philter
        4. Generate embeddings and store in database
        """
        logger.info(f"Starting synthetic data pipeline for {num_patients} patients")
        
        try:
            # Step 1: Generate synthetic patients
            await self.generate_synthea_patients(num_patients, specialties)
            
            # Step 2: Process FHIR bundles
            processed_notes = await self.process_fhir_bundles()
            
            # Step 3: De-identify PHI
            deidentified_notes = await self.deidentify_notes(processed_notes)
            
            # Step 4: Generate embeddings and store
            stored_count = await self.embed_and_store(deidentified_notes)
            
            result = {
                "status": "completed",
                "patients_generated": num_patients,
                "notes_processed": len(processed_notes),
                "notes_deidentified": len(deidentified_notes),
                "notes_stored": stored_count,
                "specialties": specialties
            }
            
            logger.info(f"Pipeline completed successfully: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Pipeline failed: {e}")
            raise
    
    async def generate_synthea_patients(self, num_patients: int, specialties: List[str]):
        """Step 1: Generate synthetic patients using Synthea Docker"""
        logger.info(f"Generating {num_patients} synthetic patients with specialties: {specialties}")
        
        # Prepare Synthea command
        output_dir = self.fhir_dir.absolute()
        modules_dir = Path("./synthea_modules").absolute()
        
        # Build specialty modules string
        specialty_modules = ",".join(specialties)
        
        cmd = [
            "docker", "run", "--rm",
            "-v", f"{output_dir}:/synthea/output",
            "-v", f"{modules_dir}:/synthea/src/main/resources/modules",
            "synthetichealth/synthea:latest",
            "-p", str(num_patients),
            "-m", f"{specialty_modules},PriorAuth",
            "--exporter.fhir.export", "true",
            "--exporter.hospital.fhir.export", "false",
            "--exporter.practitioner.fhir.export", "false"
        ]
        
        logger.info(f"Running Synthea: {' '.join(cmd)}")
        
        # Run Synthea in subprocess
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        
        if process.returncode != 0:
            logger.error(f"Synthea failed: {stderr.decode()}")
            raise RuntimeError(f"Synthea generation failed: {stderr.decode()}")
        
        logger.info(f"Synthea generation completed. Output: {stdout.decode()[:500]}")
        
        # Verify output files
        fhir_files = list(self.fhir_dir.glob("*.json"))
        logger.info(f"Generated {len(fhir_files)} FHIR bundle files")
        
        if len(fhir_files) == 0:
            raise RuntimeError("No FHIR files generated by Synthea")
    
    async def process_fhir_bundles(self) -> List[Dict[str, Any]]:
        """Step 2: Process FHIR bundles and extract clinical notes"""
        logger.info("Processing FHIR bundles and extracting clinical notes")
        
        fhir_files = list(self.fhir_dir.glob("*.json"))
        processed_notes = []
        
        for fhir_file in fhir_files:
            try:
                with open(fhir_file, 'r') as f:
                    bundle = json.load(f)
                
                # Store raw FHIR bundle in database
                patient_id = self.extract_patient_id(bundle)
                await self.store_fhir_bundle(patient_id, bundle)
                
                # Extract clinical notes
                notes = self.fhir_processor.extract_clinical_notes(bundle)
                processed_notes.extend(notes)
                
            except Exception as e:
                logger.error(f"Failed to process {fhir_file}: {e}")
                continue
        
        logger.info(f"Extracted {len(processed_notes)} clinical notes from {len(fhir_files)} bundles")
        return processed_notes
    
    async def deidentify_notes(self, notes: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Step 3: De-identify PHI in clinical notes"""
        logger.info(f"De-identifying {len(notes)} clinical notes")
        
        deidentified_notes = []
        
        for note in notes:
            try:
                original_text = note.get('text', '')
                if not original_text:
                    continue
                
                # De-identify the text
                deidentified_text = await self.deidentifier.deidentify_text(original_text)
                
                # Create deidentified note record
                deidentified_note = {
                    **note,
                    'deidentified_text': deidentified_text,
                    'original_text': original_text  # Keep for reference (would remove in production)
                }
                
                deidentified_notes.append(deidentified_note)
                
            except Exception as e:
                logger.error(f"Failed to de-identify note {note.get('note_id', 'unknown')}: {e}")
                continue
        
        logger.info(f"De-identified {len(deidentified_notes)} notes")
        return deidentified_notes
    
    async def embed_and_store(self, notes: List[Dict[str, Any]]) -> int:
        """Step 4: Generate embeddings and store in database"""
        logger.info(f"Generating embeddings and storing {len(notes)} notes")
        
        stored_count = 0
        
        for note in notes:
            try:
                # Generate embedding for deidentified text
                text_to_embed = note.get('deidentified_text', note.get('text', ''))
                if not text_to_embed:
                    continue
                
                embedding = self.embedding_service.embed_text(text_to_embed)
                
                # Store in database
                await self.store_clinical_note(note, embedding)
                stored_count += 1
                
            except Exception as e:
                logger.error(f"Failed to embed and store note {note.get('note_id', 'unknown')}: {e}")
                continue
        
        logger.info(f"Successfully stored {stored_count} notes with embeddings")
        return stored_count
    
    def extract_patient_id(self, bundle: Dict[str, Any]) -> str:
        """Extract patient ID from FHIR bundle"""
        try:
            for entry in bundle.get('entry', []):
                resource = entry.get('resource', {})
                if resource.get('resourceType') == 'Patient':
                    return resource.get('id', str(uuid.uuid4()))
            return str(uuid.uuid4())
        except Exception:
            return str(uuid.uuid4())
    
    async def store_fhir_bundle(self, patient_id: str, bundle: Dict[str, Any]):
        """Store FHIR bundle in database"""
        try:
            query = text("""
                INSERT INTO synthetic_patients (patient_id, fhir_bundle)
                VALUES (:patient_id, :bundle)
                ON CONFLICT (patient_id) DO UPDATE SET
                fhir_bundle = :bundle
            """)
            
            await self.db.execute(query, {
                "patient_id": patient_id,
                "bundle": json.dumps(bundle)
            })
            await self.db.commit()
            
        except Exception as e:
            logger.error(f"Failed to store FHIR bundle for patient {patient_id}: {e}")
            await self.db.rollback()
            raise
    
    async def store_clinical_note(self, note: Dict[str, Any], embedding: List[float]):
        """Store clinical note with embedding in database"""
        try:
            # Convert embedding to PostgreSQL array format
            embedding_str = "[" + ",".join(map(str, embedding)) + "]"
            
            query = text("""
                INSERT INTO clinical_notes (
                    patient_id, note_id, original_text, deidentified_text,
                    extracted_codes, specialty, prior_auth_required, prior_auth_status
                ) VALUES (
                    :patient_id, :note_id, :original_text, :deidentified_text,
                    :extracted_codes, :specialty, :prior_auth_required, :prior_auth_status
                )
            """)
            
            await self.db.execute(query, {
                "patient_id": note.get('patient_id', ''),
                "note_id": note.get('note_id', str(uuid.uuid4())),
                "original_text": note.get('original_text', ''),
                "deidentified_text": note.get('deidentified_text', ''),
                "extracted_codes": json.dumps(note.get('extracted_codes', {})),
                "specialty": note.get('specialty', ''),
                "prior_auth_required": note.get('prior_auth_required', False),
                "prior_auth_status": note.get('prior_auth_status', 'pending')
            })
            await self.db.commit()
            
        except Exception as e:
            logger.error(f"Failed to store clinical note {note.get('note_id', 'unknown')}: {e}")
            await self.db.rollback()
            raise 